// Copyright 2024 The Jujutsu Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use std::collections::{HashMap, HashSet};
use std::io::Write;
use std::process::Stdio;
use std::sync::mpsc::channel;

use config::ConfigError;
use futures::StreamExt;
use itertools::Itertools;
use jj_lib::backend::{BackendError, BackendResult, CommitId, FileId, TreeValue};
use jj_lib::matchers::{EverythingMatcher, Matcher};
use jj_lib::merged_tree::MergedTreeBuilder;
use jj_lib::repo::Repo;
use jj_lib::repo_path::RepoPathBuf;
use jj_lib::revset::{RevsetExpression, RevsetIteratorExt};
use jj_lib::store::Store;
use pollster::FutureExt;
use rayon::iter::IntoParallelIterator;
use rayon::prelude::ParallelIterator;
use tracing::instrument;

use crate::cli_util::{CommandHelper, RevisionArg, WorkspaceCommandHelper};
use crate::command_error::CommandError;
use crate::config::{CommandNameAndArgs, NonEmptyCommandArgsVec};
use crate::ui::Ui;

/// Update files with formatting fixes or other changes
///
/// The primary use case for this command is to apply the results of automatic
/// code formatting tools to revisions that may not be properly formatted yet.
/// It can also be used to modify files with other tools like `sed` or `sort`.
///
/// The changed files in the given revisions will be updated with any fixes
/// determined by passing their file content through the external tool.
/// Descendants will also be updated by passing their versions of the same files
/// through the same external tool, which will never result in new conflicts.
/// Files with existing conflicts will be updated on all sides of the conflict,
/// which can potentially increase or decrease the number of conflict markers.
///
/// The external tool must accept the current file content on standard input,
/// and return the updated file content on standard output. The output will not
/// be used unless the tool exits with a successful exit code. Output on
/// standard error will be passed through to the terminal.
///
/// The configuration schema is expected to change in the future. For now, it
/// defines a single command that will affect all changed files in the specified
/// revisions. For example, to format some Rust code changed in the working copy
/// revision, you could write this configuration:
///
/// [fix]
/// tool-command = ["rustfmt", "--emit", "stdout"]
///
/// And then run the command `jj fix -s @`.
#[derive(clap::Args, Clone, Debug)]
#[command(verbatim_doc_comment)]
pub(crate) struct FixArgs {
    /// Fix files in the specified revision(s) and their descendants
    #[arg(long, short)]
    source: Vec<RevisionArg>,
    /// Fix only these paths
    #[arg(value_hint = clap::ValueHint::AnyPath)]
    paths: Vec<String>,
}

#[instrument(skip_all)]
pub(crate) fn cmd_fix(
    ui: &mut Ui,
    command: &CommandHelper,
    args: &FixArgs,
) -> Result<(), CommandError> {
    let mut workspace_command = command.workspace_helper(ui)?;
    let tools_config = get_tools_config(&workspace_command, command.settings().config())?;
    let root_commits: Vec<CommitId> = workspace_command
        .parse_union_revsets(if args.source.is_empty() {
            &[RevisionArg::AT]
        } else {
            &args.source
        })?
        .evaluate_to_commit_ids()?
        .collect();
    workspace_command.check_rewritable(root_commits.iter())?;
    let matcher = workspace_command
        .parse_file_patterns(&args.paths)?
        .to_matcher();

    let mut tx = workspace_command.start_transaction();

    // Collect all of the unique `ToolInput`s we're going to use. Tools should be
    // deterministic, and should not consider outside information, so it is safe to
    // deduplicate inputs that correspond to multiple files or commits. This is
    // typically more efficient, but it does prevent certain use cases like
    // providing commit IDs as inputs to be inserted into files. We also need to
    // record the mapping between tool inputs and paths/commits, to efficiently
    // rewrite the commits later.
    //
    // If a path is being fixed in a particular commit, it must also be fixed in all
    // that commit's descendants. We do this as a way of propagating changes,
    // under the assumption that it is more useful than performing a rebase and
    // risking merge conflicts. In the case of code formatters, rebasing wouldn't
    // reliably produce well formatted code anyway. Deduplicating inputs helps
    // to prevent quadratic growth in the number of tool executions required for
    // doing this in long chains of commits with disjoint sets of modified files.
    let commits: Vec<_> = RevsetExpression::commits(root_commits.to_vec())
        .descendants()
        .evaluate_programmatic(tx.base_repo().as_ref())?
        .iter()
        .commits(tx.repo().store())
        .try_collect()?;
    let mut unique_tool_inputs: HashSet<ToolInput> = HashSet::new();
    let mut commit_paths: HashMap<CommitId, HashSet<RepoPathBuf>> = HashMap::new();
    for commit in commits.iter().rev() {
        let mut paths: HashSet<RepoPathBuf> = HashSet::new();

        // Fix all paths that were fixed in ancestors, so we don't lose those changes.
        // We do this instead of rebasing onto those changes, to avoid merge conflicts.
        for parent_id in commit.parent_ids() {
            if let Some(parent_paths) = commit_paths.get(parent_id) {
                paths.extend(parent_paths.iter().cloned());
            }
        }

        // Also fix any new paths that were changed in this commit.
        let tree = commit.tree()?;
        let parent_tree = commit.parent_tree(tx.repo())?;
        let mut diff_stream = parent_tree.diff_stream(&tree, &matcher);
        async {
            while let Some((repo_path, diff)) = diff_stream.next().await {
                let (_before, after) = diff?;
                // Deleted files have no file content to fix, and they have no terms in `after`,
                // so we don't add any tool inputs for them. Conflicted files produce one tool
                // input for each side of the conflict.
                for term in after.into_iter().flatten() {
                    // We currently only support fixing the content of normal files, so we skip
                    // directories and symlinks, and we ignore the executable bit.
                    if let TreeValue::File { id, executable: _ } = term {
                        // TODO: Consider filename arguments and tool configuration instead of
                        // passing every changed file into the tool. Otherwise, the tool has to
                        // be modified to implement that kind of stuff.
                        let tool_input = ToolInput {
                            file_id: id.clone(),
                            repo_path: repo_path.clone(),
                        };
                        unique_tool_inputs.insert(tool_input.clone());
                        paths.insert(repo_path.clone());
                    }
                }
            }
            Ok::<(), BackendError>(())
        }
        .block_on()?;

        commit_paths.insert(commit.id().clone(), paths);
    }

    // Run the configured tool on all of the chosen inputs.
    // TODO: Support configuration of multiple tools and which files they affect.
    let fixed_file_ids = fix_file_ids(
        tx.repo().store().as_ref(),
        &tools_config,
        &unique_tool_inputs,
    )?;

    // Substitute the fixed file IDs into all of the affected commits. Currently,
    // fixes cannot delete or rename files, change the executable bit, or modify
    // other parts of the commit like the description.
    let mut num_checked_commits = 0;
    let mut num_fixed_commits = 0;
    tx.mut_repo().transform_descendants(
        command.settings(),
        root_commits.iter().cloned().collect_vec(),
        |mut rewriter| {
            // TODO: Build the trees in parallel before `transform_descendants()` and only
            // keep the tree IDs in memory, so we can pass them to the rewriter.
            let repo_paths = commit_paths.get(rewriter.old_commit().id()).unwrap();
            let old_tree = rewriter.old_commit().tree()?;
            let mut tree_builder = MergedTreeBuilder::new(old_tree.id().clone());
            let mut changes = 0;
            for repo_path in repo_paths {
                let old_value = old_tree.path_value(repo_path)?;
                let new_value = old_value.map(|old_term| {
                    if let Some(TreeValue::File { id, executable }) = old_term {
                        let tool_input = ToolInput {
                            file_id: id.clone(),
                            repo_path: repo_path.clone(),
                        };
                        if let Some(new_id) = fixed_file_ids.get(&tool_input) {
                            return Some(TreeValue::File {
                                id: new_id.clone(),
                                executable: *executable,
                            });
                        }
                    }
                    old_term.clone()
                });
                if new_value != old_value {
                    tree_builder.set_or_remove(repo_path.clone(), new_value);
                    changes += 1;
                }
            }
            num_checked_commits += 1;
            if changes > 0 {
                num_fixed_commits += 1;
                let new_tree = tree_builder.write_tree(rewriter.mut_repo().store())?;
                let builder = rewriter.reparent(command.settings())?;
                builder.set_tree_id(new_tree).write()?;
            }
            Ok(())
        },
    )?;
    writeln!(
        ui.status(),
        "Fixed {num_fixed_commits} commits of {num_checked_commits} checked."
    )?;
    tx.finish(ui, format!("fixed {num_fixed_commits} commits"))
}

/// Represents the API between `jj fix` and the tools it runs.
// TODO: Add the set of changed line/byte ranges, so those can be passed into code formatters via
// flags. This will help avoid introducing unrelated changes when working on code with out of date
// formatting.
#[derive(PartialEq, Eq, Hash, Clone)]
struct ToolInput {
    /// File content is the primary input, provided on the tool's standard
    /// input. We use the `FileId` as a placeholder here, so we can hold all
    /// the inputs in memory without also holding all the content at once.
    file_id: FileId,

    /// The path is provided to allow passing it into the tool so it can
    /// potentially:
    ///  - Choose different behaviors for different file names, extensions, etc.
    ///  - Update parts of the file's content that should be derived from the
    ///    file's path.
    repo_path: RepoPathBuf,
}

/// Applies `run_tool()` to the inputs and stores the resulting file content.
///
/// Returns a map describing the subset of `tool_inputs` that resulted in
/// changed file content. Failures when handling an input will cause it to be
/// omitted from the return value, which is indistinguishable from succeeding
/// with no changes.
/// TODO: Better error handling so we can tell the user what went wrong with
/// each failed input.
fn fix_file_ids<'a>(
    store: &Store,
    tools_config: &ToolsConfig,
    tool_inputs: &'a HashSet<ToolInput>,
) -> BackendResult<HashMap<&'a ToolInput, FileId>> {
    let (updates_tx, updates_rx) = channel();
    // TODO: Switch to futures, or document the decision not to. We don't need
    // threads unless the threads will be doing more than waiting for pipes.
    tool_inputs.into_par_iter().try_for_each_init(
        || updates_tx.clone(),
        |updates_tx, tool_input| -> Result<(), BackendError> {
            let mut new_file_id: Option<FileId> = None;
            let mut prev_content: Option<Vec<u8>> = None;
            for tool_config in tools_config.tools.iter() {
                if tool_config.matcher.matches(&tool_input.repo_path) {
                    if prev_content.is_none() {
                        let mut content = vec![];
                        let mut read =
                            store.read_file(&tool_input.repo_path, &tool_input.file_id)?;
                        read.read_to_end(&mut content).unwrap();
                        prev_content = Some(content);
                    }
                    if let Ok(next_content) = run_tool(
                        &tool_config.command,
                        tool_input,
                        prev_content.as_ref().unwrap(),
                    ) {
                        if next_content != *prev_content.as_ref().unwrap() {
                            new_file_id =
                                Some(store.write_file(
                                    &tool_input.repo_path,
                                    &mut next_content.as_slice(),
                                )?);
                            prev_content = Some(next_content);
                        }
                    }
                }
            }
            if let Some(new_file_id) = new_file_id {
                updates_tx.send((tool_input, new_file_id)).unwrap();
            }
            Ok(())
        },
    )?;
    drop(updates_tx);
    let mut result = HashMap::new();
    while let Ok((tool_input, new_file_id)) = updates_rx.recv() {
        result.insert(tool_input, new_file_id);
    }
    Ok(result)
}

/// Runs the `tool_command` to fix the given file content.
///
/// The `old_content` is assumed to be that of the `tool_input`'s `FileId`, but
/// this is not verified.
///
/// Returns the new file content, whose value will be the same as `old_content`
/// unless the command introduced changes. Returns `None` if there were any
/// failures when starting, stopping, or communicating with the subprocess.
fn run_tool(
    tool_command: &CommandNameAndArgs,
    tool_input: &ToolInput,
    old_content: &[u8],
) -> Result<Vec<u8>, ()> {
    // TODO: Pipe stderr so we can tell the user which commit, file, and tool it is
    // associated with.
    let mut vars: HashMap<&str, &str> = HashMap::new();
    vars.insert("path", tool_input.repo_path.as_internal_file_string());
    let mut child = tool_command
        .to_command_with_variables(&vars)
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .spawn()
        .or(Err(()))?;
    let mut stdin = child.stdin.take().unwrap();
    let output = std::thread::scope(|s| {
        s.spawn(move || {
            stdin.write_all(old_content).ok();
        });
        Some(child.wait_with_output().or(Err(())))
    })
    .unwrap()?;
    if output.status.success() {
        Ok(output.stdout)
    } else {
        Err(())
    }
}

struct ToolConfig {
    command: CommandNameAndArgs,
    matcher: Box<dyn Matcher>,
}

struct ToolsConfig {
    tools: Vec<ToolConfig>,
}

fn get_tools_config(
    workspace_command: &WorkspaceCommandHelper,
    config: &config::Config,
) -> Result<ToolsConfig, CommandError> {
    // todo fix these names, they're terrible
    let mut tools_config = ToolsConfig { tools: Vec::new() };
    if let Ok(tool_command) = config.get("fix.tool-command") {
        tools_config.tools.push(ToolConfig {
            command: tool_command,
            matcher: Box::new(EverythingMatcher),
        });
    }
    if let Ok(tool_configs) = config.get_table("fix.tools") {
        let mut tool_configs: Vec<ToolConfig> = tool_configs
            .into_iter()
            .map(|(key, val)| -> Result<ToolConfig, CommandError> {
                let table = val.into_array()?[0].clone().into_table()?;
                let patterns: Vec<String> = table
                    .get("patterns")
                    .ok_or(config::ConfigError::NotFound(format!(
                        "tools.{}.patterns",
                        key
                    )))?
                    .clone()
                    .into_array()?
                    .into_iter()
                    .map(|value| -> Result<String, ConfigError> { value.into_string() })
                    .try_collect()?; // todo test empty patterns list
                Ok(ToolConfig {
                    command: CommandNameAndArgs::Vec(
                        NonEmptyCommandArgsVec::try_from(
                            table
                                .get("command")
                                .ok_or(config::ConfigError::NotFound(format!(
                                    "tools.{}.command",
                                    key
                                )))?
                                .clone()
                                .into_array()?
                                .iter()
                                .map(|value| value.to_string())
                                .collect_vec(),
                        )
                        .map_err(|e| {
                            config::ConfigError::Message(format!("{}: tools.{}.command", e, key))
                        })?,
                    ),
                    matcher: workspace_command
                        .parse_union_filesets(&patterns)?
                        .to_matcher(),
                })
            })
            .try_collect()?;
        tools_config.tools.append(&mut tool_configs);
    }
    if tools_config.tools.is_empty() {
        Err(config::ConfigError::Message(
            "At least one entry of `fix.tools` or `fix.tool-command` is required.".to_string(),
        )
        .into())
    } else {
        Ok(tools_config)
    }
}
